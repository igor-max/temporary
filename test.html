<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }

      .test {
        width: 500px;
        height: 300px;
        line-height: 300px;
        text-align: center;
        border: 1px solid #000;
      }
    </style>
  </head>

  <body>
    <div class="test" id="test"></div>
    <button id="btn">cancel</button>
    <script>
     
    </script>

    <!-- <script>
      function Father(name) {
        this.name = name;
      }

      function Son(name, age) {
        Father.call(this, name);
        this.age = age;
      }

      // Object.setPrototypeOf(Son.prototype, Father.prototype);
      // Son.prototype.getSon = function() {}
      // Father.prototype.getFather = function() {}

      function inherit(target, origin) {
        function Fun() {}
        Fun.prototype = origin.prototype;  // 目的就是提供一个空对象
        const fun = new Fun();
        target.prototype = fun;
        Object.defineProperty(target.prototype, 'constructor', {
          value: target,
          enumerable: false,
        });
      }

      // Son.prototype = Object.create(Father.prototype);
      inherit(Son, Father);
      Object.defineProperty(Son.prototype, 'constructor', {
        value: Son,
        enumerable: false,
      });
      Son.prototype.getSon = function () {};
      Father.prototype.getFather = function () {};

      const son = new Son('Jack', 11);
      console.log(son);

      // 原型链继承（父级函数中的this放在了原型上，存在被改的可能）

      // 放在实例上，原型链还是要指向正确
    </script> -->

    <script>
      // 链表在 while 循环的时候不能用 current， 而是用 current.next 作判断
      class Node {
        constructor(element) {
          this.element = element;
          this.next = null;
        }
      }

      class LinkedList {
        constructor() {
          this.head = null;
          this.length = 0;
        }

        get(pos) {
          if (pos < 0 || pos >= this.length) return;
        }

        append(ele) {
          const node = new Node(ele);
          let current = this.head;
          if (!current) {
            this.head = node;
          } else {
            while (current.next) {
              current = current.next;
            }
            current.next = node;
          }
          this.length++;
        }

        insert(ele, pos) {
          if (pos < 0 || pos > this.length) return;
          const node = new Node(ele);
          let current = this.head;
          if (!pos) {
            // head insert
            node.next = head;
            this.head = node;
          } else {
            while (--pos) {
              current = current.next;
            }
            node.next = current.next;
            current.next = node;
          }
          this.length++;
        }

        remove(ele) {
          let current = this.head,
            flag = true; // 减少循环使用
          if (current.element === ele) {
            this.head = null;
            this.flag = false; // 如果下面的else没找到，讲flag设置为falg，表示找到了，用这个判断要不要length-1
          } else {
            while (current.next && flag) {
              if (current.next.element === ele) {
                current.next = current.next.next;
                flag = false;
              }
              current = current.next; // 后面再重新分配，因为要拿到前一个元素
            }
          }
          if (!this.flag) {
            this.length--;
          }
        }

        site() {
          return this.length;
        }
      }

      const list = new LinkedList();

      list.append(1);
      list.append(2);
      list.append(3);
      list.append(4);
      list.append(5);

      list.insert('a', 2);

      list.remove(4);

      console.log(list);

      /*
        出行： 6 * 30 = 180 == 200
        吃饭： 40 * 30 = 1200
        住：   600    

        total： 2000
      
      */
    </script>
  </body>
</html>
